use std::fs;
use std::fs::File;
use std::io::prelude::*;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command;

use handlebars::Handlebars;
use serde::{Deserialize, Serialize};

static INPUT_TEX_NAME: &'static str = "_input_autogenerated.tex";
static OUTPUT_PDF_NAME: &'static str = "_input_autogenerated.pdf";

pub trait DocumentProvider<T>
where
    for<'de> T: Serialize + Deserialize<'de>,
    for<'de> Self: Sized + Deserialize<'de>,
{
    fn init(id: u32) -> Result<Self, DocumentError>; // Implement
    fn set_data(self, data: T) -> Result<Self, DocumentError>; // Should implement
    fn get_data(&self) -> Option<&T>; // Should implement
    fn get_location(&self) -> &'static str; // Should implement
    fn get_id(&self) -> u32;

    /// Set data as str, and try to convert it to Self
    /// Data must be json serialized object that has a type: Self
    fn set_data_str(self, query_data: &str) -> Result<Self, DocumentError> {
        let object: Self = serde_json::from_str(query_data)
            .map_err(|e| DocumentError::SerializationError(e.to_string()))?;
        Ok(object)
    }

    /// Create document
    fn create_document(self) -> Result<Self, DocumentError> {
        // Create path to the final PDF
        let pdf_path = std::path::PathBuf::from(format!(
            "data/documents/{}/{}.pdf",
            self.get_location(),
            self.get_id()
        ));

        // Check if the file already exist
        if pdf_path.exists() {
            return Err(DocumentError::IdTaken { id: self.get_id() });
        }

        // Register a new handlebars instance
        let reg = Handlebars::new();

        // Create temp template variable
        let mut template: String = String::new();

        // Define template_path to get access tempalte file(s)
        let template_path = Path::new("templates").join(self.get_location());

        // Read template file
        File::open(&template_path.join("template.tex"))
            .map_err(|e| {
                DocumentError::InternalError(format!(
                    "A template.tex file nem nyitható meg! {}",
                    e.to_string()
                ))
            })?
            .read_to_string(&mut template)
            .map_err(|e| {
                DocumentError::InternalError(format!(
                    "A template.tex file nem olvasható! {}",
                    e.to_string()
                ))
            })?;

        // render without register
        let rendered_template = reg
            .render_template(&template, &self.get_data())
            .map_err(|e| DocumentError::RenderError(e.to_string()))?;

        // Create temp dir for template files
        let tmp = tempdir::TempDir::new("pdf_render")
            .map_err(|_| DocumentError::InternalError(format!("Temp folder error")))?;

        // Copy all the template files into the temp dir
        fs::read_dir(&template_path)
            .map_err(|e| {
                DocumentError::InternalError(format!(
                    "template folder read error! {}",
                    e.to_string()
                ))
            })?
            .into_iter()
            .for_each(|f| {
                if let Ok(file) = f {
                    let _ = fs::copy(file.path(), &tmp.path().join(file.file_name()));
                }
            });

        // Set auto generated input tex file path to generate and fill with data
        let input_file_path = tmp.path().join(INPUT_TEX_NAME);

        // Generate parsed tex file
        let _ = File::create(&input_file_path).map_err(|e| {
            DocumentError::InternalError(format!(
                "input auto generated tex file cannot created! {}",
                e.to_string()
            ))
        })?;

        // Write rendered tex template to the input tex file
        let _ = fs::write(&input_file_path, rendered_template).map_err(|e| {
            DocumentError::InternalError(format!(
                "Hiba az auto generált latex file mentésekor! {}",
                e.to_string()
            ))
        })?;

        fs::read_dir(&tmp)
            .unwrap()
            .into_iter()
            .for_each(|f| println!("File: {:?}", f.unwrap().file_name()));

        // Set output PDF path
        let output_file_path = tmp.path().join(OUTPUT_PDF_NAME);

        let mut cmd = Command::new("pdflatex");

        cmd.args(&[INPUT_TEX_NAME]);

        cmd.current_dir(tmp.path());

        let cmd_output = cmd.output().map_err(|e| {
            DocumentError::InternalError(format!("Error while pdflatex render! {}", e.to_string()))
        })?;

        if !cmd_output.status.success() {
            return Err(DocumentError::InternalError(format!(
                "Error while pdflatex render!"
            )));
        }

        let mut pdf_bytes = fs::read(&output_file_path).map_err(|e| {
            DocumentError::InternalError(format!("Failed to read the generated PDF file! {}", e))
        })?;

        let document_path = std::path::PathBuf::from(format!(
            "data/documents/{}/{}.pdf",
            &self.get_location(),
            &self.get_id()
        ));

        fs::create_dir_all(&format!("data/documents/{}", &self.get_location())).map_err(|e| {
            DocumentError::InternalError(format!(
                "Error while creating root path for document! {}",
                e.to_string()
            ))
        })?;

        let mut document_file = File::create(&document_path).map_err(|e| {
            DocumentError::InternalError(format!("Failed to create generated PDF file!"))
        })?;

        File::write_all(&mut document_file, &mut pdf_bytes).map_err(|e| {
            DocumentError::InternalError(format!(
                "Error while writing content to generated PDF! {}",
                e.to_string()
            ))
        })?;

        document_file
            .flush()
            .map_err(|e| DocumentError::InternalError(format!("Flush error: {}", e.to_string())))?;

        Ok(self)
    }

    /// Get document as byte array
    fn get_document_bytes(&self) -> Result<Vec<u8>, DocumentError> {
        // Create document path
        let document_path = std::path::PathBuf::from(format!(
            "data/documents/{}/{}.pdf",
            &self.get_location(),
            &self.get_id()
        ));

        // Check wheter the requested document exist
        if !&document_path.exists() {
            return Err(DocumentError::NotFound {
                kind: self.get_location(),
                id: self.get_id(),
            });
        }

        // Read document as bytes array and return it
        fs::read(&document_path).map_err(|e| {
            DocumentError::InternalError(format!(
                "Could not read the requested document! {}",
                e.to_string()
            ))
        })
    }

    /// Get document as base64 string
    fn get_document_base64(&self) -> Result<String, DocumentError> {
        let document_bytes = self.get_document_bytes()?;
        Ok(base64_encode(&document_bytes))
    }
}

// Encode bytes array
fn base64_encode(input: &Vec<u8>) -> String {
    base64::encode(input)
}

#[derive(Debug)]
pub enum DocumentError {
    SerializationError(String),
    NotFound { kind: &'static str, id: u32 },
    IdTaken { id: u32 },
    RenderError(String),
    FileError(String),
    InternalError(String),
}

#[derive(Debug)]
pub enum DocumentKind {
    CashIn,
    CashOut,
    Procurement,
    InventoryLog,
    // ..
}

impl ToString for DocumentKind {
    fn to_string(&self) -> String {
        match self {
            DocumentKind::CashIn => format!("cash_in"),
            DocumentKind::CashOut => format!("cash_out"),
            DocumentKind::Procurement => format!("procurement"),
            DocumentKind::InventoryLog => format!("inventory_log"),
        }
    }
}
