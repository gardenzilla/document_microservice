use std::fs;
use std::fs::File;
use std::io::prelude::*;
use std::io::Write;
use std::process::Command;

use handlebars::Handlebars;
use serde::{Deserialize, Serialize};

static INPUT_TEX_NAME: &'static str = "_input_autogenerated.tex";
static OUTPUT_PDF_NAME: &'static str = "_input_autogenerated.pdf";

pub trait DocumentProvider<T>
where
    for<'de> T: Serialize + Deserialize<'de>,
    for<'de> Self: Sized + Deserialize<'de>,
{
    fn init(id: u32) -> Result<Self, DocumentError>; // Implement
    fn set_data(self, data: T) -> Result<Self, DocumentError>; // Should implement
    fn get_data(&self) -> Option<&T>; // Should implement
    fn get_location(&self) -> &'static str; // Should implement
    fn get_id(&self) -> u32;

    /// Set data as str, and try to convert it to Self
    /// Data must be json serialized object that has a type: Self
    fn set_data_str(self, query_data: &str) -> Result<Self, DocumentError> {
        let object: Self = serde_json::from_str(query_data)
            .map_err(|e| DocumentError::SerializationError(e.to_string()))?;
        Ok(object)
    }

    /// Create document
    fn create_document(self) -> Result<Self, DocumentError> {
        // Create path to the final PDF
        let pdf_path = std::path::PathBuf::from(format!(
            "data/documents/{}/{}.pdf",
            self.get_location(),
            self.get_id()
        ));

        // Check if the file already exist
        if pdf_path.exists() {
            return Err(DocumentError::IdTaken { id: self.get_id() });
        }

        // Register a new handlebars instance
        let reg = Handlebars::new();

        // Create temp template variable
        let mut template: String = String::new();

        // Read template file
        File::open(&format!("templates/{}/template.tex", self.get_location()))
            .map_err(|e| {
                DocumentError::InternalError(format!(
                    "A template.tex file nem nyitható meg! {}",
                    e.to_string()
                ))
            })?
            .read_to_string(&mut template)
            .map_err(|e| {
                DocumentError::InternalError(format!(
                    "A template.tex file nem olvasható! {}",
                    e.to_string()
                ))
            })?;

        // render without register
        let rendered_template = reg
            .render_template(&template, &self.get_data())
            .map_err(|e| DocumentError::RenderError(e.to_string()))?;

        // Create temp dir for template files
        let tmp = tempdir::TempDir::new("pdf_render")
            .map_err(|_| DocumentError::InternalError(format!("Temp folder error")))?;

        // Copy all the template files into the temp dir
        fs::read_dir(tmp.path())
            .map_err(|e| {
                DocumentError::InternalError(format!(
                    "template folder read error! {}",
                    e.to_string()
                ))
            })?
            .into_iter()
            .for_each(|f| {
                if let Ok(file) = f {
                    let _ = fs::copy(file.path(), tmp);
                }
            });

        // Set auto generated input tex file path to generate and fill with data
        let input_file_path = tmp.path().join(INPUT_TEX_NAME);

        // Generate parsed tex file
        let input_file = File::create(&input_file_path).map_err(|e| {
            DocumentError::InternalError(format!(
                "input auto generated tex file cannot created! {}",
                e.to_string()
            ))
        })?;

        // Write rendered tex template to the input tex file
        let _ = fs::write(&input_file_path, rendered_template).map_err(|e| {
            DocumentError::InternalError(format!(
                "Hiba az auto generált latex file mentésekor! {}",
                e.to_string()
            ))
        })?;

        // Set output PDF path
        let output_file_path = tmp.path().join(OUTPUT_PDF_NAME);

        let mut cmd = Command::new("pdflatex");

        cmd.args(&[INPUT_TEX_NAME]);

        cmd.current_dir(tmp.path());

        let cmd_output = cmd.output().map_err(|e| {
            DocumentError::InternalError(format!("Error while pdflatex render! {}", e.to_string()))
        })?;

        if !cmd_output.status.success() {
            return Err(DocumentError::InternalError(format!(
                "Error while pdflatex render!"
            )));
        }

        let mut pdf_bytes = fs::read(&output_file_path).map_err(|e| {
            DocumentError::InternalError(format!("Failed to read the generated PDF file! {}", e))
        })?;

        let document_path = std::path::PathBuf::from(format!(
            "data/documents/{}/{}.pdf",
            &self.get_location(),
            &self.get_id()
        ));

        fs::create_dir_all(&document_path).map_err(|e| {
            DocumentError::InternalError(format!(
                "Error while creating root path for document! {}",
                e.to_string()
            ))
        })?;

        let mut document_file = File::create(&document_path).map_err(|e| {
            DocumentError::InternalError(format!("Failed to create generated PDF file!"))
        })?;

        File::write_all(&mut document_file, &mut pdf_bytes).map_err(|e| {
            DocumentError::InternalError(format!(
                "Error while writing content to generated PDF! {}",
                e.to_string()
            ))
        })?;

        document_file
            .flush()
            .map_err(|e| DocumentError::InternalError(format!("Flush error: {}", e.to_string())))?;

        Ok(self)
    }

    /// Get document as byte array
    fn get_document_bytes(&self) -> Result<Vec<u8>, DocumentError> {
        // Create document path
        let document_path = std::path::PathBuf::from(format!(
            "data/documents/{}/{}.pdf",
            &self.get_location(),
            &self.get_id()
        ));

        // Check wheter the requested document exist
        if !&document_path.exists() {
            return Err(DocumentError::NotFound {
                kind: self.get_location(),
                id: self.get_id(),
            });
        }

        // Read document as bytes array and return it
        fs::read(&document_path).map_err(|e| {
            DocumentError::InternalError(format!(
                "Could not read the requested document! {}",
                e.to_string()
            ))
        })
    }

    /// Get document as base64 string
    fn get_document_base64(&self) -> Result<String, DocumentError> {
        let document_bytes = self.get_document_bytes()?;
        Ok(base64_encode(&document_bytes))
    }
}

// Encode bytes array
fn base64_encode(input: &Vec<u8>) -> String {
    base64::encode(input)
}

#[derive(Debug)]
pub enum DocumentError {
    SerializationError(String),
    NotFound { kind: &'static str, id: u32 },
    IdTaken { id: u32 },
    RenderError(String),
    FileError(String),
    InternalError(String),
}

#[derive(Debug)]
pub enum DocumentKind {
    CashIn,
    CashOut,
    Procurement,
    InventoryLog,
    // ..
}

impl ToString for DocumentKind {
    fn to_string(&self) -> String {
        match self {
            DocumentKind::CashIn => format!("cash_in"),
            DocumentKind::CashOut => format!("cash_out"),
            DocumentKind::Procurement => format!("procurement"),
            DocumentKind::InventoryLog => format!("inventory_log"),
        }
    }
}

impl DocumentKind {
    fn get_location(&self) -> &'static str {
        match self {
            DocumentKind::CashIn => "cash_in",
            DocumentKind::CashOut => "cash_out",
            DocumentKind::Procurement => "procurement",
            DocumentKind::InventoryLog => "inventory_log",
        }
    }
    fn get_template(&self) -> &'static str {
        match self {
            DocumentKind::CashIn => std::include_str!("templates/latex/cash_in/cash_in.tex"),
            DocumentKind::CashOut => std::include_str!("templates/latex/cash_out/cash_out.tex"),
            DocumentKind::Procurement => {
                std::include_str!("templates/latex/procurement/procurement.tex")
            }
            DocumentKind::InventoryLog => {
                std::include_str!("templates/latex/inventory_log/inventory_log.tex")
            }
        }
    }
}

#[derive(Debug)]
pub enum Method {
    Get,
    Post,
}

impl ToString for Method {
    fn to_string(&self) -> String {
        match self {
            Method::Get => format!("get"),
            Method::Post => format!("post"),
        }
    }
}

#[derive(Debug)]
pub struct QueryResponse {
    kind: DocumentKind,
    id: String,
    document_pdf_base64: String,
}

// Render Latex &str to PDF
// Returns the generated pdf file as byte vector
// todo!: should have better error handling: latex parse error, and process error
fn pdf_render(latex: &str) -> Result<Vec<u8>, RenderError> {
    let tmp = tempdir::TempDir::new("pdf_render").map_err(|_| RenderError::TempDirError)?;
    let input_file = tmp.path().join("input.tex");
    let output_file = tmp.path().join("input.pdf");

    let _ = fs::write(&input_file, latex).map_err(|_| RenderError::TexFileCreationError)?;

    let mut cmd = Command::new("pdflatex");

    cmd.args(&["input.tex"]);

    cmd.current_dir(tmp.path());

    let output = cmd
        .output()
        .map_err(|e| RenderError::RenderError(e.to_string()))?;

    if !output.status.success() {
        return Err(RenderError::PdfLatexError);
    }

    fs::read(output_file).map_err(|e| RenderError::PdfReadError(e.to_string()))
}

pub fn create_document<T>(
    id: u32,
    kind: DocumentKind,
    data: T,
) -> Result<QueryResponse, DocumentError>
where
    T: Serialize,
{
    let pdf_path =
        std::path::PathBuf::from(format!("data/documents/{}/{}.pdf", kind.get_location(), id));

    if pdf_path.exists() {
        return Err(DocumentError::IdTaken { id: id });
    }

    let reg = Handlebars::new();
    // render without register
    let res = reg
        .render_template(kind.get_template(), &data)
        .map_err(|e| DocumentError::RenderError(e.to_string()))?;

    let mut pdf_vec = pdf_render(&res).map_err(|e| DocumentError::RenderError(e.to_string()))?;
    println!("Vec is {:?}", &pdf_vec);

    // Create dir if not exist
    if let Some(root_path) = pdf_path.parent() {
        fs::create_dir_all(root_path).map_err(|e| DocumentError::FileError(e.to_string()))?;
    }

    let mut file = std::fs::File::create(pdf_path).unwrap();

    file.write_all(&mut pdf_vec)
        .map_err(|e| DocumentError::FileError(e.to_string()))?;

    file.flush()
        .map_err(|e| DocumentError::FileError(e.to_string()))?;

    Ok(QueryResponse {
        kind: kind,
        id: format!("{:x}", id),
        document_pdf_base64: "".into(),
    })
}

pub fn load_document(
    method: Method,
    kind: DocumentKind,
    id: u32,
) -> Result<QueryResponse, DocumentError> {
    todo!()
}
